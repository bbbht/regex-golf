# 正则
### Warmup
正确字符串都包含子串foo
```
foo
```

---
### Anchors
正确字符串都以k结尾  
使用定位符 $
```
k$
```

---
### It never ends
题目要求不得使用$   
使用另一种定位符 \b，匹配字符串边界
```
u\b
```

---
### Ranges
组成正确字符串的字母都在a-f范围内  
使用定位符 ^ 和 $ 匹配字符串开头和结尾  
通过[a-f]进行字符类限制  
并通过限定符 + 来限制字符长度
```
^[a-f]+$
```

---
### Backrefs
三字符重复   
使用\1来引用第一个()匹配到的内容，代表重复
```
(...).*\1
```

---
### Abba
通过标题abba观察到错误字符串都符合abba的模式  
同样使用引用来解决重复  
并通过使用 ``(?!)`` (正向否定查找)配合 ^ 来完成匹配
```
^(?!.*(.)(.)\2\1)
```

---
### A man, a plan
字符串重复问题
```
^(.)(.).*\2\1$
```

---
### Prime
用正则匹配质数  
原理为重复：  
    1. (..+)至少匹配2个字符  
    2. \1+表示将上述匹配字符至少重复一次  
以上两条结合，保证``(..+)\1+$``匹配到的字符串数量可分解（2\*n，3\*n等等）  
然后再辅以正向否定查找，完成匹配
```
^(?!(..+)\1+$)
```

---
### Four
正确的字符串都包含一个重复四次的字母  
使用{}限定重复次数
```
(.)(.\1){3}
```

---
### Order
初看标题，暴力尝试``^[\x61-\x6D][\x63-\x6F]``未果  
根据正确字符串长度为5或6  
排除错误字符串oriole即可(``[^e]?``)
```
^.{5}[^e]?$
```

---
### Powers
反向匹配，即先完成只匹配错误字符串  
``.(..)+``锁匹配的数量肯定为大于1的奇数，然后使用``\1*``来不限次数的重复，即可保证所匹配到的数量为一个奇数的整数倍  
然后使用``(?!)``正向否定,以及``^$``进行边界限定，即可实现只匹配2的幂次方数量的字符  
使用数学来描述 ``(1 + 2 * m) * n`` m：正整数，n：非负整数，肯定得不出2的幂次方结果
```
^(?!(.(..)+)\1*$)
```

---
### Powers 2
Google得正解  
理解了贪婪模式 ``+`` 的含义：每一次的匹配，并非恒定的数量，而是先尽量多的匹配，然后渐少，直至完成匹配  
初始暴力解决方案``^(.{1,729}|.{868,})\1\1$|^.$``（28字符）  
``\2``重复一次，``(?=\2$)``再重复一次并匹配字符串结尾，但此组并不包含在结果中。达到平分为三组，但只匹配两组的目的  
进而再对剩余的部分，重复进行如上步骤，直至最后一组为单独的字符``x``，保证了每一组都能被三整除，直至1  
> 如 xxxxxxxxx  
> ``(x+)``贪婪匹配9个，但后续无法匹配，于是直至减至3，完成匹配  
> 匹配结果是三组中的前两组，即前6个  
> 由于``*``存在，最后三个继续进行上述操作，第二次会匹配第7、第8个，完成表达式``^((x+)\2(?=\2$))*``的匹配  
> 最后以x结束，完成整个表达式的匹配
```
^((x+)\2(?=\2$))*x$
```

---
### Long count
如果以空格分隔，并以四个数字为一组，可发现两边数据区别，即左侧无重复  
使用``(\d{4}).*\1``即可匹配到所有的重复项，然后取反即可  
即``^(?!.*(\d{4}).*\1)``（18字符）  
从答案中发现了14字符的答案，虽然也是根据重复完成，然而并没有那么直观
```
((.+)0\2+1){8}
```